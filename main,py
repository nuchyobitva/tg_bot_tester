import os
from dotenv import load_dotenv
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.ext import CallbackQueryHandler
from telegram.constants import ParseMode
import random
from datetime import datetime, timedelta

load_dotenv()

TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Конфигурация теста
ADMIN_CHAT_ID = 705993924  # Замените на ваш chat_id (можно узнать у @userinfobot)
TEST = {
    "name": "Тест по современным технологиям",
    "time_limit": 20,
    "shuffle_questions": True,
    "shuffle_answers": True,
    "questions": [
        # Блокчейн и криптовалюты
        {
            "question": "Что такое блокчейн?",
            "answers": [
                "Централизованная база данных",
                "Цепочка блоков с информацией",  # Правильный ответ
                "Вид компьютерного вируса",
                "Социальная сеть"
            ],
            "correct": 1
        },
        {
            "question": "Какая была первая криптовалюта?",
            "answers": [
                "Ethereum",
                "Litecoin",
                "Bitcoin",  # Правильный ответ
                "Dogecoin"
            ],
            "correct": 2
        },
        {
            "question": "Что такое майнинг?",
            "answers": [
                "Покупка криптовалюты",
                "Процесс создания новых блоков",  # Правильный ответ
                "Взлом блокчейна",
                "Продажа цифровых активов"
            ],
            "correct": 1
        },

        # Аутентификация и безопасность
        {
            "question": "Что означает OTP?",
            "answers": [
                "One-Time Password",  # Правильный ответ
                "Online Transaction Protocol",
                "Open Transfer Process",
                "Official Test Program"
            ],
            "correct": 0
        },
        {
            "question": "Какой из этих методов НЕ относится к двухфакторной аутентификации?",
            "answers": [
                "Пароль + SMS",
                "Пароль + email",  # Правильный ответ
                "Пароль + отпечаток пальца",
                "Пароль + аппаратный ключ"
            ],
            "correct": 1
        },

        # Умные дома и IoT
        {
            "question": "Что означает IoT?",
            "answers": [
                "Internet of Things",  # Правильный ответ
                "International Online Technology",
                "Integrated Operation Terminal",
                "Internet Organization Team"
            ],
            "correct": 0
        },
        {
            "question": "Какой протокол НЕ используется в умных домах?",
            "answers": [
                "Wi-Fi",
                "Bluetooth",
                "HTTP",  # Правильный ответ
                "Zigbee"
            ],
            "correct": 2
        },

        # Нейросети и ИИ
        {
            "question": "Что такое GPT?",
            "answers": [
                "General Purpose Technology",
                "Generative Pre-trained Transformer",  # Правильный ответ
                "Global Processing Terminal",
                "Graphical Programming Tool"
            ],
            "correct": 1
        },
        {
            "question": "Где применяются генеративно-состязательные сети (GAN)?",
            "answers": [
                "Для создания изображений",  # Правильный ответ
                "Для взлома паролей",
                "Для обработки звука",
                "Для ускорения интернета"
            ],
            "correct": 0
        },

        # Кибербезопасность
        {
            "question": "Что такое фишинг?",
            "answers": [
                "Вид спорта",
                "Метод ловли рыба",
                "Кибератака через поддельные письма/сайты",  # Правильный ответ
                "Технология шифрования"
            ],
            "correct": 2
        },
        {
            "question": "Какой из этих паролей самый надежный?",
            "answers": [
                "123456",
                "qwerty",
                "John1985",
                "Xk8$zP2#mN"  # Правильный ответ
            ],
            "correct": 3
        },

        # Одноразовая почта и SMS
        {
            "question": "Для чего нужна одноразовая почта?",
            "answers": [
                "Для постоянного использования",
                "Для временной регистрации",  # Правильный ответ
                "Для хранения важных документов",
                "Для взлома аккаунтов"
            ],
            "correct": 1
        },

        # Модель OSI
        {
            "question": "Какой уровень OSI отвечает за маршрутизацию?",
            "answers": [
                "Физический",
                "Канальный",
                "Сетевой",  # Правильный ответ
                "Прикладной"
            ],
            "correct": 2
        },

        # Криптография
        {
            "question": "Что такое шифрование?",
            "answers": [
                "Удаление данных",
                "Преобразование данных в нечитаемый вид",  # Правильный ответ
                "Копирование информации",
                "Ускорение интернета"
            ],
            "correct": 1
        },

        # Социальная инженерия
        {
            "question": "Что такое социальная инженерия?",
            "answers": [
                "Строительство зданий",
                "Метод манипуляции людьми",  # Правильный ответ
                "Вид программирования",
                "Научная дисциплина"
            ],
            "correct": 1
        },

        # Облачные технологии
        {
            "question": "Что такое облачное хранилище?",
            "answers": [
                "Флеш-накопитель",
                "Удаленный сервер для хранения данных",  # Правильный ответ
                "Жесткий диск компьютера",
                "Вид компьютерного вируса"
            ],
            "correct": 1
        },

        # Веб-технологии
        {
            "question": "Что такое HTTP-протокол?",
            "answers": [
                "Протокол передачи гипертекста",  # Правильный ответ
                "Язык программирования",
                "Система шифрования данных",
                "Вид компьютерного вируса"
            ],
            "correct": 0
        },

        # Виртуализация
        {
            "question": "Что такое виртуальная машина?",
            "answers": [
                "Физический компьютер",
                "Программная эмуляция компьютера",  # Правильный ответ
                "Вид компьютерной игры",
                "Облачное хранилище"
            ],
            "correct": 1
        },

        # Базы данных
        {
            "question": "Что такое SQL?",
            "answers": [
                "Язык программирования",
                "Язык запросов к базам данных",  # Правильный ответ
                "Вид компьютерного вируса",
                "Система шифрования"
            ],
            "correct": 1
        },

        # Операционные системы
        {
            "question": "Какая ОС является Linux-дистрибутивом?",
            "answers": [
                "Windows 10",
                "macOS",
                "Ubuntu",  # Правильный ответ
                "iOS"
            ],
            "correct": 2
        },

        # Сети и телекоммуникации
        {
            "question": "Что такое IP-адрес?",
            "answers": [
                "Уникальный идентификатор устройства в сети",  # Правильный ответ
                "Пароль от Wi-Fi",
                "Номер кредитной карты",
                "Вид компьютерного вируса"
            ],
            "correct": 0
        },

        # Программирование
        {
            "question": "Какой язык используется для веб-фронтенда?",
            "answers": [
                "Python",
                "Java",
                "JavaScript",  # Правильный ответ
                "C++"
            ],
            "correct": 2
        },

        # Кибербезопасность (дополнительно)
        {
            "question": "Что такое DDoS-атака?",
            "answers": [
                "Вид спорта",
                "Массовая отправка запросов для перегрузки сервера",  # Правильный ответ
                "Способ шифрования данных",
                "Метод резервного копирования"
            ],
            "correct": 1
        }
    ]
}

# Глобальные переменные
user_sessions = {}
message_ids_to_delete = {}


class UserSession:
    class UserSession:
        def reset(self):
            self.state = "awaiting_lastname"
            self.lastname = ""
            self.firstname = ""
            self.group = ""
            self.test_start_time = None
            self.current_question = 0
            self.score = 0
            self.last_messages = []
            # Перемешиваем вопросы заново
            self.questions = TEST["questions"].copy()
            if TEST["shuffle_questions"]:
                random.shuffle(self.questions)
            if TEST["shuffle_answers"]:
                for q in self.questions:
                    answers = q['answers']
                    correct = q['correct']
                    correct_answer = answers[correct]
                    random.shuffle(answers)
                    q['correct'] = answers.index(correct_answer)


    def __init__(self, user_id):
        self.user_id = user_id
        self.state = "awaiting_lastname"
        self.lastname = ""
        self.firstname = ""
        self.group = ""
        self.test_start_time = None
        self.current_question = 0
        self.score = 0
        self.questions = TEST["questions"].copy()
        self.last_messages = []  # Для удаления предыдущих сообщений

        # Перемешивание вопросов и ответов
        if TEST["shuffle_questions"]:
            random.shuffle(self.questions)
        if TEST["shuffle_answers"]:
            for q in self.questions:
                answers = q['answers']
                correct = q['correct']
                # Сохраняем текст правильного ответа
                q['correct_text'] = answers[correct]
                random.shuffle(answers)
                # Обновляем индекс правильного ответа
                q['correct'] = answers.index(q['correct_text'])


async def delete_previous_messages(update: Update, context: ContextTypes.DEFAULT_TYPE, session):
    """Удаляет предыдущие сообщения в чате"""
    for msg_id in session.last_messages:
        try:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
        except Exception as e:
            logging.error(f"Ошибка при удалении сообщения: {e}")
    session.last_messages = []


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("По просьбе Алексея Александровича направляю вам ссылку на опрос и прошу пройти до прохождения теста\nhttps://docs.google.com/forms/d/1lcuiOglXuiSXYhlklAs2dKgpUexJATvvlAMjP89fC-Y/viewform?edit_requested=true")

    user_id = update.message.from_user.id

    # Создаем или сбрасываем сессию
    if user_id in user_sessions:
        user_sessions[user_id].reset()  # Полный сброс
    else:
        user_sessions[user_id] = UserSession(user_id)

    msg = await update.message.reply_text(
        "Добро пожаловать в систему тестирования!\n"
        "Введите вашу фамилию:"
    )
    user_sessions[user_id].last_messages.append(msg.message_id)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    text = update.message.text.strip()  # Вот где должна быть получена переменная text

    if user_id not in user_sessions:
        await update.message.reply_text("Пожалуйста, начните с команды /start")
        return

    session = user_sessions[user_id]
    session.last_messages.append(update.message.message_id)

    if session.state == "awaiting_lastname":
        session.lastname = text
        session.state = "awaiting_firstname"
        await delete_previous_messages(update, context, session)
        msg = await update.message.reply_text("Введите ваше имя:")
        session.last_messages.append(msg.message_id)

    elif session.state == "awaiting_firstname":
        session.firstname = text
        session.state = "awaiting_group"
        await delete_previous_messages(update, context, session)
        msg = await update.message.reply_text("Введите вашу группу:")
        session.last_messages.append(msg.message_id)

    elif session.state == "awaiting_group":
        session.group = text
        session.state = "testing"
        session.test_start_time = datetime.now()
        await delete_previous_messages(update, context, session)
        await send_question(update, context, session)

    elif session.state == "testing":
        current_question = session.questions[session.current_question]

        # Получаем текст правильного ответа
        correct_answer = current_question['answers'][current_question['correct']]

        # Сравниваем введенный ответ с правильным (без учета регистра)
        if text.lower() == correct_answer.lower():
            session.score += 1

        session.current_question += 1
        await delete_previous_messages(update, context, session)

        if session.current_question >= len(session.questions):
            await finish_test(update, context, session)
        else:
            await send_question(update, context, session)


from telegram import InlineKeyboardButton, InlineKeyboardMarkup


async def send_question(update: Update, context: ContextTypes.DEFAULT_TYPE, session):
    """Отправляет вопрос с кнопками вариантов ответов"""
    try:
        question = session.questions[session.current_question]
        time_left = (session.test_start_time + timedelta(minutes=TEST["time_limit"]) - datetime.now())

        if time_left.total_seconds() <= 0:
            await finish_test(update, context, session)
            return

        time_str = f"[{time_left.seconds // 60:02d}:{time_left.seconds % 60:02d}]"
        question_text = f"{time_str} Вопрос {session.current_question + 1}/{len(session.questions)}:\n{question['question']}"

        # Создаем кнопки для вариантов ответов
        keyboard = []
        for idx, answer in enumerate(question['answers']):
            callback_data = f"answer_{session.current_question}_{idx}"
            keyboard.append([InlineKeyboardButton(answer, callback_data=callback_data)])

        reply_markup = InlineKeyboardMarkup(keyboard)

        # Удаляем предыдущее сообщение с вопросом (если есть)
        if hasattr(session, 'last_message_id'):
            try:
                await context.bot.delete_message(chat_id=session.user_id, message_id=session.last_message_id)
            except:
                pass

        # Отправляем новый вопрос
        msg = await context.bot.send_message(
            chat_id=session.user_id,
            text=f"```\n{question_text}\n```",
            parse_mode=ParseMode.MARKDOWN_V2,
            reply_markup=reply_markup
        )
        session.last_message_id = msg.message_id

    except Exception as e:
        logging.error(f"Ошибка в send_question: {e}")
        await context.bot.send_message(
            chat_id=session.user_id,
            text="Произошла ошибка. Начните тест заново /start"
        )


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    if user_id not in user_sessions:
        await query.edit_message_text("Сессия истекла. Начните с /start")
        return

    session = user_sessions[user_id]

    try:
        _, question_idx, answer_idx = query.data.split('_')
        question_idx = int(question_idx)
        answer_idx = int(answer_idx)

        if question_idx != session.current_question:
            return

        # Проверяем ответ
        current_question = session.questions[session.current_question]
        if answer_idx == current_question['correct']:
            session.score += 1

        session.current_question += 1

        # Удаляем сообщение с кнопками
        await query.delete_message()

        if session.current_question >= len(session.questions):
            await finish_test(update, context, session)
        else:
            await send_question(update, context, session)

    except Exception as e:
        logging.error(f"Ошибка в button_handler: {e}")
        await query.edit_message_text("Произошла ошибка. Начните тест заново /start")

async def finish_test(update: Update, context: ContextTypes.DEFAULT_TYPE, session):
    """Завершает тест и отправляет результаты"""
    time_taken = datetime.now() - session.test_start_time
    score_percent = int((session.score / len(session.questions)) * 100)

    # Формируем результат для студента
    student_result = (
        f"Тест завершен!\n"
        f"Результаты для {session.lastname} {session.firstname} ({session.group}):\n"
        f"Правильных ответов: {session.score}/{len(session.questions)}\n"
        f"Процент: {score_percent}%\n"
        f"Затраченное время: {time_taken.seconds // 60:02d}:{time_taken.seconds % 60:02d}"
    )

    # Формируем компактный результат для администратора
    admin_result = f"Группа {session.group}\n {session.lastname} {session.firstname}\n Результат : {session.score}/{len(session.questions)} "

    try:
        # Отправляем результаты студенту
        await context.bot.send_message(
            chat_id=session.user_id,
            text=f"```\n{student_result}\n```",
            parse_mode=ParseMode.MARKDOWN_V2
        )

        # Отправляем результаты администратору
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text=admin_result
        )
    except Exception as e:
        logging.error(f"Ошибка при отправке результатов: {e}")
    finally:
        # Очищаем сессию
        if session.user_id in user_sessions:
            del user_sessions[session.user_id]


def main():
    application = Application.builder().token("7724050180:AAFI_yWUzKQDz_Kzygkle-MuAy5Z8jQ3rrE").build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button_handler))  # Добавляем обработчик кнопок

    application.run_polling()


if __name__ == '__main__':
    main()

